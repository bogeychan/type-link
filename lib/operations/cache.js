import * as fs from 'node:fs';
import * as path from 'node:path';
import * as crypto from 'node:crypto';

import JSON5 from 'json5';
import { Project } from 'ts-morph';

import { getMyVersion, stringify } from '../utils.js';

const TYPE_LINK_TSCONFIG_NAME = 'type-link.tsconfig.jsonc';
const TYPE_LINK_TSCONFIG = `./${TYPE_LINK_TSCONFIG_NAME}`;

/**
 * @param {{ target: string, getConfigFile: () => any, tmpdir: string, writeConfigFile: (config: any) => void, options: object }} arguments
 */
export async function execute({
  target,
  getConfigFile,
  tmpdir,
  writeConfigFile,
  options
}) {
  if (options.clear) {
    fs.rmSync(tmpdir, { recursive: true });
    return;
  }

  const destination = path.join(process.cwd(), target);

  const project = new Project();
  project.addSourceFileAtPath(destination);

  /**
   * @type {Set<string>}
   */
  const moduleSpecifiers = new Set();

  /**
   * @param {import("ts-morph").SourceFile} sourceFile
   */
  function resolveModuleSpecifiersIn(sourceFile) {
    for (const importDeclaration of sourceFile.getImportDeclarations()) {
      const moduleSpecifier = importDeclaration
        .getModuleSpecifier()
        .getLiteralValue();

      if (
        moduleSpecifier.startsWith('http://') ||
        moduleSpecifier.startsWith('https://')
      ) {
        moduleSpecifiers.add(moduleSpecifier);
      } else {
        const file = importDeclaration.getModuleSpecifierSourceFile();

        if (!file) continue;

        resolveModuleSpecifiersIn(file);
      }
    }
  }

  for (const sourceFile of project.getSourceFiles()) {
    resolveModuleSpecifiersIn(sourceFile);
  }

  const config = getConfigFile();

  if (!config.files) {
    config.files = {};
  }

  const typeDeclaration = {
    compilerOptions: {
      paths: {}
    }
  };

  /**
   * @param {string} name
   * @param {string} filepath
   */
  function declareModule(name, filepath) {
    if (!typeDeclaration.compilerOptions.paths[name]) {
      typeDeclaration.compilerOptions.paths[name] = [];
    }

    /**
     * @type {string[]}
     */
    const modulepaths = typeDeclaration.compilerOptions.paths[name];

    if (!modulepaths.includes(filepath)) {
      modulepaths.push(filepath);
    }
  }

  for (const moduleSpecifier of moduleSpecifiers) {
    if (moduleSpecifier in config.files) {
      // cache hit

      if (options.reload) {
        const modulepath = config.files[moduleSpecifier];

        const moduledirpath = fs.lstatSync(modulepath).isDirectory()
          ? modulepath
          : path.dirname(modulepath);

        fs.rmSync(moduledirpath, { recursive: true });

        await processNewModuleSpecifier({
          moduleSpecifier,
          config,
          declareModule,
          tmpdirpath: moduledirpath
        });
      }

      declareModule(moduleSpecifier, config.files[moduleSpecifier]);
      continue;
    }

    await processNewModuleSpecifier({
      moduleSpecifier,
      config,
      declareModule,
      tmpdirpath: path.join(tmpdir, crypto.randomUUID())
    });
  }

  writeConfigFile(config);

  const cwd = process.cwd();

  fs.writeFileSync(
    path.join(cwd, TYPE_LINK_TSCONFIG),
    `// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// type-link tsconfig v${getMyVersion()}
${stringify(typeDeclaration)}`
  );

  const tsconfigpath = path.join(cwd, 'tsconfig.json');

  const tsconfig = fs.existsSync(tsconfigpath)
    ? JSON5.parse(fs.readFileSync(tsconfigpath, { encoding: 'utf-8' }))
    : {};

  if (tsconfig['extends'] !== TYPE_LINK_TSCONFIG) {
    tsconfig['extends'] = TYPE_LINK_TSCONFIG;
    fs.writeFileSync(tsconfigpath, stringify(tsconfig, JSON5));
  }

  const gitignorepath = path.join(cwd, '.gitignore');

  const gitignore = fs.existsSync(gitignorepath)
    ? fs.readFileSync(gitignorepath, { encoding: 'utf-8' }).split(/\r?\n/)
    : [];

  let found = false;

  for (const line of gitignore) {
    if (line === TYPE_LINK_TSCONFIG_NAME) {
      found = true;
      return;
    }
  }

  if (!found) {
    fs.writeFileSync(
      gitignorepath,
      [TYPE_LINK_TSCONFIG_NAME, ...gitignore].join('\r\n')
    );
  }
}

/**
 * @param {string} url
 */
async function requestFile(url) {
  const response = await fetch(url);
  const text = await response.text();

  if (!response.ok) {
    console.log(`Can't load "${url}", ${text}`);
    return;
  }

  return text;
}

/**
 *
 * @param {{moduleSpecifier: string, config: any, declareModule: (moduleSpecifier: string, filepath: string) => void, tmpdirpath: string}} arguments
 */
async function processNewModuleSpecifier({
  moduleSpecifier,
  declareModule,
  config,
  tmpdirpath
}) {
  if (moduleSpecifier.endsWith('.d.ts')) {
    const text = await requestFile(moduleSpecifier);

    if (typeof text === 'undefined') {
      return;
    }

    fs.mkdirSync(tmpdirpath);

    const filename = path.basename(moduleSpecifier);
    const filepath = path.join(tmpdirpath, filename);

    config.files[moduleSpecifier] = filepath;

    fs.writeFileSync(filepath, text);

    declareModule(moduleSpecifier, filepath);
  } else {
    console.log(
      `Unsupported import "${moduleSpecifier}", file an issue on Github!`
    );
  }
}
